# 2주차 정리

## **React에서의 동시성과 병렬성은 어떻게 해석되고 구현되는가?**

(류지예, 조명근)

### 개념

동시성(Concurrency), 병렬성(Parallelism)

- 동시성
  - 작업들을 번갈아가며 수많은 작업들을 처리해가는 것, '마치' 동시에 처리되는 것처럼 보이게 함
- 병렬성
  - 여러 작업을 동시에 수행하는 것

### 등장 배경

컴퓨터에서

1. 초기 컴퓨터의 운영 과정이 복잡한 문제로 설정 시간이 많이 소모되는 걸 해결하기 위해 여러 사람이 동시에 컴퓨터를 사용할 수 있도록 운영체제를 개발함.
2. 하나의 CPU 처리장치 자원을 어떻게 공유 할 수 있을지 고민 → 프로그램을 더 작은 단위로 쪼개서 CPU가 해당 작업을 번갈아가며 실행할 수 있도록 함
3. CPU에서 복수의 코어 개념이 등장, 기존에 동시성을 사용한 멀티태스킹 → 멀티 코어를 사용한 멀티태스킹 방식

React에서 이 개념들을 도입한 이유는 React 16 이전의 문제점 때문인데,

- 렌더링이 한 번 시작되면 중단할 수 없었음
- 모든 상태 업데이트가 동일한 우선순위로 처리
- 무거운 작업이 UI를 블로킹

그래서 문제들을 해결하기 위해 React는

1. 동시성: 렌더링 작업을 중단/재개 가능하게하기 위해 도입
2. 병렬성: 데이터 로딩을 효율적으로 처리하기 위해 도입

### Frontend와 동시성

1. Javascript는 단일 스레드 언어, "병렬성"에 대한 개념보다 "동시성"에 대한 개념이 적용되어 있다.
2. 동시성 핸들링에 유리하게 설계된 Javascript는 브라우저에서 Event Loop라는 "매커니즘"을 통해 비동기 작업을 관리합니다.

### React에서 동시성 구현

1. Fiber 아키텍처 : 중단 가능한 렌더링을 구현하기 위해 도입했다.

- 핵심은 작업을 작은 단위로 쪼개고 우선순위를 부여하는 것

`workLoopConcurrent`는 React의 렌더링 작업이 실제로 어떻게 나뉘고 처리되는지 보여줍니다.

```jsx
function workLoopConcurrent() {
  while (workInProgress !== null && !shouldYield()) {
    performUnitOfWork(workInProgress);
  }
}
```

- 작업을 작은 단위(`workInProgress`)로 분할
- 각 작업 후 양보(`shouldYield`) 여부 확인
- 필요시 현재 작업을 중단하고 나중에 재개 가능

1. 우선순위 체계 : 어떤 작업이 더 급한지 판단할 수 있도록 `Lane`이라는 우선순위 체계를 도입

```jsx
export const SyncLane = 0b0000000000000000000000000000001;
export const InputContinuousLane = 0b0000000000000000000000000000100;
export const DefaultLane = 0b0000000000000000000000000010000;
```

- `SyncLane`: 즉시 처리해야 하는 작업 (예: 클릭 이벤트)
- `InputContinuousLane`: 사용자 입력 관련 작업
- `DefaultLane`: 일반적인 우선순위의 업데이트

### React에서 동시성을 관리하는 방법

1. 동시성
   기본 개념은 "UI렌더링은 사용자의 행동을 Block하면 안된다." 였다. 이는 렌더링으로 사용자의 행동이 block되면 사용성에 큰 영향을 끼치기 때문이였다. React18에서 `Automatic Batching`을 도입하면서 불필요한 렌더링을 줄일 수 있었습니다.

그럼 React에서 동시성의 우선순위는 어떻게 정해질까요?

1. 우선순위
   - Immediate Priority (ImmediatePriority): 사용자 입력과 같이 즉각적인 반응이 필요한 작업에 사용됩니다.
   - User Blocking Priority (UserBlockingPriority): 사용자 상호작용 후 즉시 처리해야 하는 작업.
   - Normal Priority (NormalPriority): 일반적인 렌더링 업데이트 작업.
   - Low Priority (LowPriority): 비긴급적인 작업 (예: 백그라운드 업데이트).
   - Idle Priority (IdlePriority): 거의 모든 작업이 완료된 후 처리할 수 있는 작업.
2. Transition :React18 부터는 개발자가 주도해서 동시성을 컨트롤 할 수 있도록 해줍니다.

   - `startTransition` : UI Block을 일으키지 않고 상태를 변경
   - `useTransition` : transition이 진행중인지 알려주는 `isPending` 상태값을 제공
   - `useDeferredValue` : transition이 일어나는 상태값을 레핑합니다. `startTransition`과 같은 역할을 합니다.

3. React 19에서의 발전

**향상된 동시성: 비동기 Transition(**비동기 함수를 직접 지원하여 동시성 처리를 개선)

- 비동기 작업과 상태 업데이트를 하나의 중단 가능한 단위로 처리
- 새로운 입력이 들어오면 이전 작업을 자동으로 취소
- 더 나은 UI 응답성: 사용자 입력이 차단되지 않음

**향상된 병렬성: use Hook**

새로운 `use` Hook은 Promise 기반의 데이터 로딩을 더 효율적으로 만듭니다:

- Promise가 어디서 시작되는지 명확히 볼 수 있어 명시적으로 데이터 로딩 가능
- 중첩된 Suspense 없이도 병렬 로딩 가능한 단순한 구조를 가짐
- 조건문이나 루프 안에서도 사용 가능

### React의 병렬성 접근 : `Suspense` 도입

Suspense는 데이터가 준비될 때까지 컴포넌트 렌더링을 "일시 중단"할 수 있게 해주는 기능입니다:

- 여러 데이터를 병렬로 로딩
- 준비된 UI부터 순차적 표시
- 로딩 상태를 자동으로 처리

### 참고 자료

- [React 18: Concurrency](https://react.dev/blog/2022/03/29/react-v18#what-is-concurrent-react)
- [React 18 톺아보기 - 02. Lane 모델](https://goidle.github.io/react/in-depth-react18-lane/)
- [[번역] 동시성, 병렬성, 그리고 자바스크립트에 대한 이해](https://velog.io/@surim014/concurrency-and-parallelism)
- [[번역] React 19에서 새롭게 등장하는 클라이언트 사이드 훅](https://velog.io/@typo/new-client-side-hooks-react-19)
- [[번역] 동시성, 병렬성, 그리고 자바스크립트에 대한 이해](https://velog.io/@surim014/concurrency-and-parallelism)
- [CONCURRENCY IS NOT WHAT YOU THINK](https://www.youtube.com/watch?v=3X93PnKRNUo)
- [Deview2021](<https://deview.kr/data/deview/session/attach/1_Inside%20React%20(%E1%84%83%E1%85%A9%E1%86%BC%E1%84%89%E1%85%B5%E1%84%89%E1%85%A5%E1%86%BC%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%80%E1%85%AE%E1%84%92%E1%85%A7%E1%86%AB%E1%84%92%E1%85%A1%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%80%E1%85%B5%E1%84%89%E1%85%AE%E1%86%AF).pdf>)

# React 19에서 상태의 개념과 동작원리가 변하는가?

(심미진)

1. 액션(Actions) : **컨벤션에 따라 비동기 트랜지션을 사용하는 함수**

e.g `useState`로 대기와 에러 상태 다루기 가능

React19에서는 트랜지션에서 비동기 함수를 사용하여 대기 상태, 에러, 양식, 낙관적 업데이트를 자동으로 처리하는 기능이 추가됨 `useTransition`을 사용하여 대기 상태를 다룸

```jsx
// 액션에서 대기 상태 사용하기
function UpdateName({}) {
  const [name, setName] = useState("");
  const [error, setError] = useState(null);
  const [isPending, startTransition] = useTransition();

  const handleSubmit = () => {
    startTransition(async () => {
      const error = await updateName(name);
      if (error) {
        setError(error);
        return;
      }
      redirect("/path");
    });
  };

  return (
    <div>
      <input value={name} onChange={(event) => setName(event.target.value)} />
      <button onClick={handleSubmit} disabled={isPending}>
        Update
      </button>
      {error && <p>{error}</p>}
    </div>
  );
}
```

비동기 트랜지션은 `isPending` 값을 즉시 true로 설정하며 비동기 요청
→ 트랜지션이 수행되면 `isPending`을 false로 전환

- 이러한 방식은 데이터가 변경되는 동안에도 현재 UI의 반응성 및 상호작용을 유지 가능.

- React19는 낙관적 업데이트의 처리를 위한 [`useOptimistic`](https://react.dev/blog/2024/04/25/react-19#new-feature-optimistic-updates), 액션의 일반적인 사용을 다루기 위한 새로운 훅 [`React.useActionstate`](https://react.dev/blog/2024/04/25/react-19#new-hook-useactionstate)을 도입
- `react-dom`에서는 양식을 자동으로 관리하는 [`form` 액션](https://react.dev/blog/2024/04/25/react-19#form-actions), 양식에서 액션을 지원하는 [`useFormStatus`](https://react.dev/blog/2024/04/25/react-19#new-hook-useformstatus) 추가하고 있다.
- React19에서는 위의 예시를 아래와 같이 단순하게 작성 가능

```jsx
// <form> 액션과 useActionState 사용
function ChangeName({ name, setName }) {
  const [error, submitAction, isPending] = useActionState(
    async (previousState, formData) => {
      const error = await updateName(formData.get("name"));
      if (error) {
        return error;
      }
      redirect("/path");
      return null;
    },
    null
  );

  return (
    <form action={submitAction}>
      <input type="text" name="name" />
      <button type="submit" disabled={isPending}>
        Update
      </button>
      {error && <p>{error}</p>}
    </form>
  );
}
```

### 새로운 훅: `useActionState`

액션의 일반적인 경우를 더 쉽게 처리하기 위해 `useActionState` 훅을 추가

- `useActionState`는 함수("액션")를 받아 호출할 래핑된 액션을 반환.
  - 이는 각 액션이 조합되므로 가능, 래핑된 액션이 호출되면 `useActionState`는 액션의 마지막 결과를 `data`로, 액션의 대기 상태를 `pending`으로 반환합니다.

### 리액트 DOM 새로운 훅: `useFormStatus`

컴포넌트가 속한 `<form>`에 대한 정보를 접근을 좀 더 쉽게 다루도록 `useFormStatus` 훅을 새롭게 추가

```jsx
import { useFormStatus } from "react-dom";

function DesignButton() {
  const { pending } = useFormStatus();
  return <button type="submit" disabled={pending} />;
}
```

`useFormStatus` 훅은 컨텍스트 프로바이더처럼 부모의 `<form>`의 상태를 읽습니다.

### 새로운 훅: `useOptimistic`

데이터 변경을 수행할 때 비동기 요청이 진행되는 동안 최종 상태를 낙관적으로 표시하는 것도 흔한 UI 패턴.

```jsx
function ChangeName({ currentName, onUpdateName }) {
  const [optimisticName, setOptimisticName] = useOptimistic(currentName);

  const submitAction = async (formData) => {
    const newName = formData.get("name");
    setOptimisticName(newName);
    const updatedName = await updateName(newName);
    onUpdateName(updatedName);
  };

  return (
    <form action={submitAction}>
      <p>Your name is: {optimisticName}</p>
      <p>
        <label>Change Name:</label>
        <input
          type="text"
          name="name"
          disabled={currentName !== optimisticName}
        />
      </p>
    </form>
  );
}
```

- `useOptimistic` 훅은 `updateName` 요청이 진행되면 `optimisticName` 값을 바로 보여줌
  - 업데이트가 종료되거나 실패하면 리액트는 자동으로 `currentName` 값으로 다시 전환됨

### 새로운 훅: `use`

리액트 19에서는 렌더링에서 리소스를 읽는 새로운 API인 `use`를 도입.

- e.g `use`로 프로미스를 읽는 경우, 프로미스가 해결(resolve)될 때까지 리액트는 일시 중단됨

# useSyncExternalStore

(이지훈, 성지현)

외부 상태 관리 스토어와 React의 동시성 렌더링(Concurrent Rendering)을 안전하게 연동하기 위해 설계

## 기존 문제점 : 동시성 렌더링 모드에서 외부 스토어의 상태 변경이 일관성을 해치는 문제 발생

- Tearing 현상
  React의 Concurrent 렌더링 환경에서 발생할 수 있는 UI 불일치 현상을 의미한다.(간혹 동일한 데이터를 보여주는 UI 컴포넌트들이 서로 다른 값을 표기하는 버그)

useEffect를 사용한 구독은 비동기적이며, Concurrent 모드에서 렌더링이 중단될 수 있다.

이렇게되면 서로다른 사용자마다 서로다른 데이터를 보게됨(금융, 병원등 데이터 일관성이 중요할 때 치명적 오류)

이런 문제를 useSyncExternalStore로 해결할 수 있다.

```tsx
function Counter1() {
  const count = useSyncExternalStore(
    store.subscribe, // 구독 함수
    store.getValue // 값을 가져오는 함수
  );

  return <div>Count: {count}</div>;
}

function Counter2() {
  const count = useSyncExternalStore(store.subscribe, store.getValue);

  return <div>Count: {count}</div>;
}
```

변경하고나서는 상태 업데이트가 동기적으로 처리된다.

React가 렌더링 도중 스토어 값이 변경되면 즉시 감지하고 모든 컴포넌트가 동일한 시점의 데이터를 보여준다.

이렇게 useSyncExternalStore을 이용해 외부 상태를 구독할 때 useEffect를 사용하는 방식의 한계와 상태 업데이트 동기화 문제를 해결함.

## useSyncExternalStore로 해결한 문제

외부 스토어의 업데이트를 동기적으로 처리

스토어 변경 사항을 React의 렌더링 사이클과 안전하게 동기화

서버 사이드 렌더링(SSR) 지원 개선

## 동작코드 살펴보기

```tsx
const snapshot = useSyncExternalStore(
  subscribe: (onStoreChange: () => void) => () => void,
  getSnapshot: () => T,
  getServerSnapshot?: () => T
);

```

### subscribe

- 스토어 구독을 설정하는 함수로 스토어 변경 시 호출될 콜백을 받는다.
- 구독 해제 함수를 반환해야한다.
- 렌더링 간에 안정적인 참조를 유지해야 한다.

### getSnapshot

- 스토어의 현재 상태를 반환하는 함수다. 스토어가 변경되지 않았다면 동일한 값을 반환해야 한다.
- 반환값은 불변(immutable)이어야 함

### getServerSnapshot (optional)

- SSR 시 사용될 초기 상태를 반환하는 함수
- 서버와 클라이언트 간 일관된 상태 유지에 사용

### 초기 렌더링

getSnapshot으로 초기 값 획득 → inst 객체 생성 및 상태 초기화 → useLayoutEffect에서 동기화 확인 → useEffect에서 구독 설정

### 업데이트 발생

외부 스토어 변경 → handleStoreChange 호출 → 스냅샷 확인 → 필요시 리렌더링

### 클린업

useEffect의 클린업 함수 실행 → 구독 해제

## 주요 특징

- 동기적 업데이트
  - 외부 스토어의 변경사항은 항상 동기적으로 처리
- startTransition으로 래핑되어도 동기적 처리 유지
- React 상태 업데이트와의 일관성 보장

### 성능 최적화

- 불필요한 리렌더링 방지
  - 값이 변경되지 않았다면 이전 스냅샷을 재사용한다.
  - 새로운 값일 때만 새 객체가 생성된다.
- 스토어 업데이트의 배치 처리 지원
- 선택적인 메모이제이션 지원

### 안전성

- Concurrent Mode에서의 데이터 일관성 보장
- 메모리 누수 방지
- 컴포넌트 언마운트 시 자동 정리

## 중요 포인트

- getSnapshot 결과는 반드시 캐시
  - React 에서는 Object.is로 비교한다.
  - 캐싱 전략을 사용해 메모리 사용량과 성능의 균현을 맞춰야한다.
- subscribe 함수는 안정적인 참조를 유지
- 상태는 불변성을 유지
- 애플리케이션 코드에서는 가능한 내장 상태 관리 사용 권장
- 복잡한 상태 로직은 별도의 스토어로 분리

## 실사용 예시 : zustand

### zustand 내부 코드

```tsx
// zustand의 Store는 setState/getState/getInitialState/subscribe를 가짐
export interface StoreApi<T> {
  setState: SetStateInternal<T>;
  getState: () => T;
  getInitialState: () => T;
  subscribe: (listener: (state: T, prevState: T) => void) => () => void;
}

const createStoreImpl: CreateStoreImpl = (createState) => {
  type TState = ReturnType<typeof createState>;
  type Listener = (state: TState, prevState: TState) => void;
  let state: TState; // zustand 스토어가 관리할 상태
  const listeners: Set<Listener> = new Set(); // 상태를 TODO

  const setState: StoreApi<TState>["setState"] = (partial, replace) => {
    const nextState =
      typeof partial === "function" // setter 함수를 받으면
        ? (partial as (state: TState) => TState)(state) // 함수 실행한 결과를 nextState로
        : partial; // 함수가 아니면 그 값을 그대로 활용
    if (!Object.is(nextState, state)) {
      // 현재 상태와 nextState 비교
      // nextState와 state가 다르다면
      const previousState = state; // 현재 상태는 이전 상태로 취급
      state = // 현재 상태는
        // replace가 true라면 nextState를 덮어쓰고
        // replace가 false이면서 nextState가 객체가 아니라면 nextState를 덮어쓰고
        // replace가 false이면서 nextState가 객체라면 state와 nextState를 병합
        replace ?? (typeof nextState !== "object" || nextState === null)
          ? (nextState as TState)
          : Object.assign({}, state, nextState);
      // 스토어를 구독하는 함수들 모두 호출
      listeners.forEach((listener) => listener(state, previousState));
    }
  };

  // 현재 상태 반환
  const getState: StoreApi<TState>["getState"] = () => state;

  // 이니셜 상태 반환
  const getInitialState: StoreApi<TState>["getInitialState"] = () =>
    initialState;

  // 상태가 바뀌면 호출할 함수들을 등록하거나 지움
  const subscribe: StoreApi<TState>["subscribe"] = (listener) => {
    listeners.add(listener);
    // Unsubscribe
    return () => listeners.delete(listener);
  };

  const api = { setState, getState, getInitialState, subscribe };
  const initialState = (state = createState(setState, getState, api));
  return api as any;
};

export const createStore = ((createState) =>
  createState ? createStoreImpl(createState) : createStoreImpl) as CreateStore;
```

```tsx
// react.ts
// react에서 zustand를 사용하는 경우
import React from "react";
import { createStore } from "./vanilla.ts";
import type {
  Mutate,
  StateCreator,
  StoreApi,
  StoreMutatorIdentifier,
} from "./vanilla.ts";

export function useStore<TState, StateSlice>(
  api: ReadonlyStoreApi<TState>,
  selector: (state: TState) => StateSlice = identity as any
) {
  const slice = React.useSyncExternalStore(
    api.subscribe, // 스토어(에 저장된 상태)를 구독하게 해주는 함수
    () => selector(api.getState()), // 스토어에 저장된 현재 상태를 반환하는 함수 전달
    () => selector(api.getInitialState()) // 스토어에 저장된 이니셜 상태를 반환하는 함수 전달
  );
  React.useDebugValue(slice); // React DevTools에서 커스텀훅(=useStore)에 label을 추가할 수 있는 훅
  return slice;
}

const createImpl = <T,>(createState: StateCreator<T, [], []>) => {
  const api = createStore(createState); // { setState, getState, getInitialState, subscribe }

  const useBoundStore: any = (selector?: any) => useStore(api, selector);

  Object.assign(useBoundStore, api);

  return useBoundStore;
};

export const create = (<T,>(createState: StateCreator<T, [], []> | undefined) =>
  createState ? createImpl(createState) : createImpl) as Create;
```

- React+Zustand 환경에서 create로 스토어를 만드는 것은 결국
  - zustand 내부적으로 구현된 스토어의 형태를
  - useSyncExternalStore로 래핑하는 것

### 참고자료

- [React-v18-useSyncExternalStore](https://react.dev/blog/2022/03/29/react-v18#usesyncexternalstore)
- [useSyncExternalStore](https://ko.react.dev/reference/react/useSyncExternalStore)
- [useMutableSource → useSyncExternalStore](https://github.com/reactwg/react-18/discussions/86)
- [useSyncExternalStore- Github 코드](https://github.com/facebook/react/blob/main/packages/use-sync-external-store/src/useSyncExternalStoreShim.js)
- [useSyncExternalStoreShimClient.js의 핵심 로직](https://github.com/facebook/react/blob/main/packages/use-sync-external-store/src/useSyncExternalStoreShimClient.js)
