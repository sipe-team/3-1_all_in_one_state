# 불변성(Immutability)

zustand의 immer에 대해 알기전에 불변성에 대해 알아보자.

불변성은 한번 생성된 데이터의 상태가 변경되지 않는다는 개념이다.

직접 수정을 금지하고, 변경이 필요할 때 새로운 객체를 생성해 원본 데이터의 무결성을 유지해야한다.

## 불변성의 핵심 역할

1. 예측 가능한 상태 변화 : 상태 변경이 직접적인 수정이 아닌 새로운 참조를 통해 이루어지므로, 상태 변화를 추적하고 예측하기 쉬워진다.

2. 성능 최적화 : React의 렌더링 최적화는 참조 비교에 기반한다. 불변성을 통해 객체 참조 변경을 빠르게 확인하기에, 불필요한 렌더링을 방지할 수 있다.

3. 상태 보존 : 각 상태 변화에서 새로운 객체를 생성해 이전 상태를 보존할 수 있다. 이를 통해 상태 변화를 추적할 수 있다.

## 참조 비교

참조 비교는 메모리 관점에서 두 값이 동일한 메모리 주소를 가리키고 있는지를 확인하는 것을 의미한다.

### 메모리와 참조의 관계

- 모든 객체는 고유한 메모리 주소를 가진다.
- 참조는 변수가 실제 데이터가 저장된 메모리 주소를 가리키는 포인터를 의미한다.
- 두 참조를 비교할 때는 실제 값이 아닌 메모리 주소를 비교

### 참조 비교의 특성

원시값은 값 자체를 비교하고, 참조값은 메모리 주소를 비교한다.

- 얕은 비교: 객체의 최상위 레벨에서만 참조를 비교
- 깊은 비교: 객체의 모든 중첩 레벨에서 값을 비교

<br>

# zustand immer 미들웨어

깊은 객체 구조에서 수동으로 불변성을 관리하는 것은 복잡하고 에러가 발생하기 쉽다

특히 스프레드 연산자, Object.assign() 같은 방식은 깊은 중첩 구조에서 코드가 매우 복잡해질 수 있다.

immer은 draft 객체를 이용해 객체를 직접 수정하는 것처럼 간단하게 처리할 수 있다.

## draft 객체

불변성을 유지하면서도 마치 직접 객체를 수정하는 것처럼 코드를 작성할 수 있게 해주는 패턴을 의미한다.

기존 상태를 복사하여 임시 객체(draft)를 만들고, 이를 수정한 후 최종적으로 새로운 불변 객체를 생성한다.

```javascript
const baseState = {
  name: "John",
  age: 30,
};

// produce는 아래에서 설명

const nextState = produce(baseState, (draft) => {
  draft.age += 1; // 마치 직접 수정하는 것처럼 보임
});
```

Proxy를 사용하여 모든 변경 사항을 추적한다.

> Proxy 란?
>
> ```javascript
> const target = {
>   name: "John",
>   age: 30,
> };
>
> const handler = {
>   get: function (target, prop) {
>     return target[prop];
>   },
>   set: function (target, prop, value) {
>     target[prop] = value;
>     return true;
>   },
> };
>
> const proxy = new Proxy(target, handler);
> ```
>
> - 프록시는 객체에 대한 기본 동작(함수호출, 속성에 대한 접근, 속성 열거)를 가로채고 재정의 하는 것을 의미한다.
>
> - 원본 객체를 감싸는 가상의 객체를 생성한다.
>
> - 모든 작업을 중간에서 감시하고 제어
>
> - 미들웨어와 같은 개념

<br>

실제로는 원본 객체를 수정하지 않고, 변경사항을 기록한다. 최종적으로 모든 변경사항을 적용한 새로운 불변 객체 생성한다.

이것을 zustand에서 immer을 사용하는 코드로 변경하면 아래처럼 구조를 변경할 수 있다.

```javascript
import create from "zustand";
import { immer } from "zustand/middleware/immer";

const useStore = create(
  immer((set) => ({
    users: [],
    addUser: (user) =>
      set((state) => {
        state.users.push(user);
      }),
  }))
);
```

## zustand immer 코드 깊이 분석해보자.

모든 코드를 깊이 분석하는 것보다 핵심 구현부인 immerImpl에 대해서 공부해보자

```typescript
const immerImpl: ImmerImpl = (initializer) => (set, get, store) => {
  type T = ReturnType<typeof initializer>;

  store.setState = (updater, replace, ...a) => {
    const nextState = (
      typeof updater === "function" ? produce(updater as any) : updater
    ) as ((s: T) => T) | T | Partial<T>;

    return set(nextState, replace as any, ...a);
  };

  return initializer(store.setState, get, store);
};
```

우선 immerImpl 함수는 store creator를 받아서 새로운 store creator을 반환하는 고차 함수다.

> store create
>
> - Zustand에서 상태(state)와 액션(actions)을 포함하는 스토어를 생성하는 함수
> - set(상태 업데이트 함수),get(현재 상태를 가져오는 함수),store(스토어 객체 자체에 대한 참조)로 구성됨

이후 store의 setState를 재정의한다.

그 다음 updater을 처리하는데, updater이 함수인 경우와 아닌 경우를 구분해서 함수면 Immer의 produce로 감싸서 불변성을 보장하고, 아니면 객체 그대로 사용한다.

마지막으로 원본 set 함수를 호출하고, 수정된 setState로 initializer을 반환한다.

### produce 함수

```typescript
function produce<Base, Return>(
  base: Base,
  recipe: (draft: Draft<Base>) => Return,
  patchListener?: PatchListener
): Base extends undefined ? Return : Return extends undefined ? Base : Return;
```

produce 함수는 현재 상태의 Base, 상태를 수정하는 함수 recipe(진짜 github에서 타입명 recipe로 되어있음), patchListener로 구성되어있다.

프록시 객체인(draft)를 생성하고, recipe 함수를 실행 및 수정사항을 추적한다.

변경사항을 분석해서 새로운 상태를 생성해 변경사항이 있을때 변경을 적용해서, 없으면 원본을 반환한다.

### 타입 안전성 보장

```typescript
as((s: T) => T) | T | Partial<T>;
```

위 코드가 이해가 안되어서 찾아보니, 반환값의 타입을 명시적으로 지정한것이라한다.

함수, 전체 상태 객체, 부분 상태 객체 모두 지원하기 위해서!

# valtio
