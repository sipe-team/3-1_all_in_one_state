# 4주차 개인 주제

## Redux Toolkit의 내부 구현과 최적화 전략

### redux toolkit은 왜 필요했을까?

> 간단히 말하자면 redux를 더 쉽게 사용하기 위해서입니다. 이름 그대로 redux를 위한 도구 모음인 것이지요.

사실 redux에는 여러가지 문제가 있었습니다. 대표적으로 언급되는 redux의 3가지 문제는 아래와 같습니다.

공통에서도 이야기했지만, redux는 보일러플레이트, 즉 어떤 일을 하기 위해 꼭 작성해야 하는 (상용구)코드를 너무 많이 요구합니다.
그리고 전역 상태관리 측면에서 보았을 때, redux 스토어 환경 설정은 너무 복잡하고 이를 유용하게 사용하려면 많은 패키지를 추가해야 합니다.

그래서 툴킷이 등장하게 됩니다.

> 공식 문서에 따르면 RTK는 리덕스 로직을 작성하는 표준 방식이 되기 위한 의도로 만들어졌다고 해요!

물론 툴킷이 리덕스가 가진 모든 문제를 해결할 수 는 없겠지만 리액트가 Create ReactApp(CRA)를 통해서 개발 접근성을 높였듯이 RTK도 복잡한 리덕스 설정 과정을 포함해서 유스 케이스 전반에 걸쳐 추상화를 시도했다는 것을 알게 되었습니다.

이 툴킷에서 제공하는 함수는 사용자에게 애플리케이션 코드를 간단히 작성할 수 있도록 지원하는데 집중하고 있었습니다.

그렇다면, RTK는 어떻게 이전의 리덕스 코어 라이브러리가 가진 복잡함을 단순화시킬 수 있던 것일까요?

RTK에서 제공하는 7가지 주요 API를 예제와 함께 살펴보시죠.

1. `configuareStore()` : createStore를 추상화한 함수로, 기본 설정을 자동화합니다.

```typescript
import { configureStore } from "@reduxjs/toolkit";
import rootReducer from "./reducers";
const store = configureStore({ reducer: rootReducer });
```

위처럼 선언하면 기본 미들웨어로 `redux-thunk`를 추가하고 개발 환경에서 리덕스 개발자 도구(Redux DeviTools Extension)를 활성화해줍니다.

```typescript
const store = configureStore({
  reducer,
  middleware: (getDefaultMiddleware) => getDefaultMiddleware().concat(logger),
  devTools: process.env.NODE_ENV !== "production",
  preloadedState,
  enhancers: [reduxBatch],
});
```

- reducer: 리듀서에는 단일 함수를 전달하여 스토어의 루트 리듀서(root reducer)로 바로 사용할 수 있습니다.
  또한 슬라이스 리듀서들로 구성된 객체를 전달하여 루트 리듀서를 생성하도록 할 수 있습니다. 이런 경우에는 내부적으로 기존 리덕스 combineReducers 함수를 사용해서 자동적으로 병합하여 루트 리듀서를 생성합 니다.
- middleware: 기본적으로는 리덕스 미들웨어를 담는 배열입니다. 사용할 모든 미들웨어를 배열에 담아서 명 시적으로 작성할 수도 있는데요. 그렇지 않으면 getDefaultMiddLeware 를 호출하게 됩니다. 사용자 정 의, 커스텀 미들웨어를 추가하면서 동시에 리덕스 기본 미들웨어를 사용할 때 유용한 방법입니다.
- deviTools: 불리언값으로 리덕스 개발자 도구를 끄거나 켭니다.
- preloadedState: 스토어의 초기값을 설정할 수 있습니다.
- enchaners: 기본적으로는 배열이지만 콜백 함수로 정의하기도 합니다. 예를 들어 다음과 같이 작성하면 개발 자가 원하는 Store enhancer 를 미들웨어가 적용되는 순서보다 앞서서 추가할 수 있습니다

2. `createReducer()` : 상태에 변화를 일으키는 리듀서 함수를 생성하는 유틸 함수입

내부적으로 immer 라이브러리 사용하여 mutative한 코드, 예시로 `state.todos[3]. compLeted = true` 형태로 작성해도 불변(immutable) 업데이트가 이루어지도록 로직을 간단히 할 수 있습니다.

그렇지 않으면 아래처럼 중첩된 모든 단계에서 복사가 필요한데요. 이는 사용자의 실수로 원본 객체에 직접적인 변형을 일으키거나 얕은 복사가 이루어지는 등, 다양한 사이드 이펙트를 발생시켜 애플리케이션이 예기치 않게 동 작할 위험성이 있습니다. 게다가 코드가 길어지기도 하고요.

```typescript
// 기존 스위치 문으로 이루어진 카운터 리듀서 함수입니다.
// 많은 보일러플레이트 코드와 에러를 발생시키기 쉬운 구조를 보여주고 있습니다.

function todosReducer(state = [], action) {
  switch (action.type) {
    case "UPDATE_VALUE": {
      return {
        ...state,
        first: {
          ...state.first,
          second: {
            ...state.first.second,
            [action.someId]: {
              ...state.first.second[action.someId],
              fourth: action.someValue,
            },
          },
        },
      };
    }
    default: {
      return state;
    }
  }
}

// 하지만 createReducer 함수를 사용하면 아래처럼 간단히 작성할 수 있습니다.

const todosReducer = createReducer((state = []), (builder) => {
  builder.addCase("UPDATE_VALUE", (state, action) => {
    const { someId, someValue } = action.payload;

    state.first.second[someId].fourth = someValue;
  });
});
```
