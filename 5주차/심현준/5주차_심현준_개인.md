# Tanstack Queryê°€ ì œì‹œí•˜ëŠ” ì„œë²„ ì‚¬ì´ë“œ í”„ë¦¬ í˜ì¹­ íŒ¨í„´

> Tanstack QueryëŠ” ì¼ë°˜ì ìœ¼ë¡œ client sideì—ì„œ dataë¥¼ ê°€ì ¸ì˜¤ëŠ” ëª©ì ìœ¼ë¡œ ë§ì´ ì‚¬ìš©í•˜ëŠ”ë°ìš”,
> nextjsì™€ ê°™ì€ SSR í”„ë ˆì„ì›Œí¬ì™€ í•¨ê»˜ ì‚¬ìš©ì‹œ Tanstack QueryëŠ” ì–´ë–¤ í•´ë²•ì„ ì œì‹œí•˜ê³  ìˆì„ê¹Œìš”?
> [Advanced Server Rendering](https://tanstack.com/query/latest/docs/framework/react/guides/advanced-ssr) ì±•í„°ì˜ ë‚´ìš©ì„ ë¶„ì„í•´ë³´ì•˜ìŠµë‹ˆë‹¤.

### Tanstack Queryì˜ ì„œë²„ ì‚¬ì´ë“œ í”„ë¦¬í˜ì¹­ íŒ¨í„´

íƒ ìŠ¤íƒ ì¿¼ë¦¬ëŠ” ì„œë²„ ì‚¬ì´ë“œ ë Œë”ë§ í”„ë ˆì„ì›Œí¬ê³¼ í•¨ê»˜ ì‚¬ìš©ì‹œ ë‹¤ìŒê³¼ ê°™ì€ íŒ¨í„´ì„ ì œì‹œí•©ë‹ˆë‹¤

1. queryClient.fetchQuery || queryClient.prefetchQuery ë¡œ queryë¥¼ fetchí›„ ì¿¼ë¦¬ í´ë¼ì´ì–¸íŠ¸ìºì‹œì— ì €ì¥ ( ë‘ í•¨ìˆ˜ì˜ ì°¨ì´ì ì€ í›„ìˆ í•˜ê² ìŠµë‹ˆë‹¤. )
2. dehydrateë¡œ ì¿¼ë¦¬ ìºì‹œì˜ ëª¨ë“  ì¿¼ë¦¬ë¥¼ ìˆœíšŒí•˜ë©° ì¿¼ë¦¬ì˜ ì§ë ¬í™”( serialize )ê°€ëŠ¥í•œ ë°ì´í„°ë¥¼ ì¶”ì¶œí•©ë‹ˆë‹¤.
3. HydrationBoundary ì»´í¬ë„ŒíŠ¸ : dehydrateëœ ì¿¼ë¦¬ë¥¼ ì¿¼ë¦¬ìºì‹œì— ë‹¤ì‹œ ë³µì›í•©ë‹ˆë‹¤.

```tsx
// app/posts/page.tsx
import { dehydrate, HydrationBoundary, QueryClient } from "@tanstack/react-query";
import Posts from "./posts";

export default async function PostsPage() {
	const queryClient = new QueryClient();

	// ì™œ awaitë§Œ í•˜ê³  ëë‚˜ëŠ”ì§€ ìƒê°í•´ë´…ì‹œë‹¤.
	await queryClient.prefetchQuery({
		queryKey: ["posts"],
		queryFn: getPosts,
	});

	return (
		// ì¿¼ë¦¬ í´ë¼ì´ì–¸íŠ¸ë¥¼ dehydrateí•œ ê²°ê³¼ë¬¼ì„ state propìœ¼ë¡œ ì£¼ì…
		<HydrationBoundary state={dehydrate(queryClient)}>
			<Posts />
		</HydrationBoundary>
	);
}
```

### 1. queryClient.fetchQuery ë„Œ ë„ëŒ€ì²´ ë¬´ìŠ¨ ì¼ì„ í•˜ëŠ”ê±°ì•¼?

```tsx
// packages/query-core/src/queryClient.ts

 fetchQuery<
    TQueryFnData,
    TError = DefaultError,
    TData = TQueryFnData,
    TQueryKey extends QueryKey = QueryKey,
    TPageParam = never,
  >(
    options: FetchQueryOptions<
      TQueryFnData,
      TError,
      TData,
      TQueryKey,
      TPageParam
    >,
  ): Promise<TData> {
		// { ...defaultOption , ...options }
		// ê¸°ë³¸ ì˜µì…˜ê³¼ ì‚¬ìš©ì ì˜µì…˜ì„ ë³‘í•©
    const defaultedOptions = this.defaultQueryOptions(options)

		// retry ì˜µì…˜ì´ ì—†ë‹¤ë©´ falseë¡œ ì´ˆê¸°í™”
    if (defaultedOptions.retry === undefined) {
      defaultedOptions.retry = false
    }

		// ì¿¼ë¦¬ í´ë¼ì´ì–¸íŠ¸ì˜ ì¿¼ë¦¬ ìºì‹œì— ì¿¼ë¦¬ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.
    const query = this.#queryCache.build(this, defaultedOptions)

		// ì¿¼ë¦¬ì˜ staleì—¬ë¶€ì— ë”°ë¼ fetch or returnì„ ê²°ì •
    return query.isStaleByTime(
      resolveStaleTime(defaultedOptions.staleTime, query),
    )
      ? query.fetch(defaultedOptions) // ìƒˆë¡œìš´ ë°ì´í„°ë¥¼ ì„œë²„ì—ì„œ ê°€ì ¸ì˜´
      : Promise.resolve(query.state.data as TData)  // ìºì‹œëœ ë°ì´í„°ë¥¼ ì¦‰ì‹œ ë°˜í™˜
  }
```

-   **queryClient.fetchQuery // ì¿¼ë¦¬í´ë¼ì´ì–¸íŠ¸ ì¸ìŠ¤í„´ìŠ¤ ë‚´ì¥ ë©”ì„œë“œ**
    -   ì¿¼ë¦¬ë¥¼ fetchí•´ì„œ ì¿¼ë¦¬ ìºì‹œì— ì €ì¥í•©ë‹ˆë‹¤. ( ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ì¿¼ë¦¬ë¼ë©´ query.stateë¥¼ resolveí•˜ì—¬ ë°˜í™˜)

### fetchQuery VS prefetchQuery

queryClient.fetchQueryëŠ” ì‘ë‹µë°ì´í„°ë¥¼ ì§ì ‘ í™œìš©í•˜ê³  ì‹¶ê±°ë‚˜, ì˜ˆì™¸ì²˜ë¦¬ë¥¼ ì§ì ‘ ì²˜ë¦¬í•˜ê³  ì‹¶ì€ ê²½ìš° ì‚¬ìš©í•©ë‹ˆë‹¤.

ë°˜ë©´ queryClient.prefetchQueryì˜ ê´€ì‹¬ì‚¬ëŠ” prefetch ìš”ì²­ì— ìˆìœ¼ë¯€ë¡œ, í•´ë‹¹ ì¿¼ë¦¬ì˜ ì„±ê³µ / ì‹¤íŒ¨ ì¼€ì´ìŠ¤ì— ëŒ€í•œ ì²˜ë¦¬ë¥¼ ë¬´ì‹œí•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ë™ì‘í•©ë‹ˆë‹¤.

```tsx
// packages/query-core/src/queryClient.ts

 prefetchQuery<
    TQueryFnData = unknown,
    TError = DefaultError,
    TData = TQueryFnData,
    TQueryKey extends QueryKey = QueryKey,
  >(
    options: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,
  ): Promise<void> {
    **return this.fetchQuery(options).then(noop).catch(noop)
    // ë‚´ë¶€ì ìœ¼ë¡œ fetchQueryë¥¼ í˜¸ì¶œ
    // ì°¨ì´ì ì€ ì„±ê³µ / ì‹¤íŒ¨ ì¼€ì´ìŠ¤ì— ëŒ€í•´ ì•„ë¬´ ë™ì‘ì„ ìˆ˜í–‰í•˜ì§€ ì•ŠëŠ” í•¨ìˆ˜(noop)ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤.
    // const noop = () => { }**
  }

```

> ì¦‰, fetchQueryëŠ” try-catch ì˜ˆì™¸ ì²˜ë¦¬ë¥¼ í•˜ê±°ë‚˜ ì‘ë‹µ ë°ì´í„°ë¥¼ ì§ì ‘ í™œìš©í•´ì•¼ í•  ë•Œ ì‚¬ìš©í•˜ê³ , ë°ì´í„°ì˜ ì„±ê³µ/ì‹¤íŒ¨ ì—¬ë¶€ë¥¼ ì‹ ê²½ ì“°ì§€ ì•Šì•„ë„ ëœë‹¤ë©´ prefetchQueryë¥¼ await í•©ë‹ˆë‹¤.

---

### 2. dehydrateë€?

-   **dehydrate**
    -   ì¿¼ë¦¬ í´ë¼ì´ì–¸íŠ¸ì˜ queryCacheë¥¼ ëª¨ë‘ ê°€ì ¸ì™€ ìˆœíšŒí•˜ë©° queryì˜ \*ì§ë ¬í™”(serialize)ê°€ëŠ¥í•œ ë°ì´í„°ë¥¼ ì¶”ì¶œí•©ë‹ˆë‹¤.
    -   *ì§ë ¬í™”(serialize) : server â†’ client ë¡œ ì „ì†¡ë˜ëŠ” ë°ì´í„°ëŠ” ì§ë ¬í™” ê°€ëŠ¥ ê°ì²´ë§Œ ì§€ì›í•©ë‹ˆë‹¤.  
        *Map, Set, Function ë“± ì§ë ¬í™” ë¶ˆê°€í•œ ë°ì´í„°ëŠ” í´ë¼ì´ì–¸íŠ¸ ì‚¬ì´ë“œë¡œ ì „ì†¡í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.
    -   ì¶”ì¶œë°ì´í„°:
        -   query.state (ì¿¼ë¦¬ ìƒíƒœ)
        ```
        export interface QueryState<TData = unknown, TError = DefaultError> {
          data: TData | undefined
          dataUpdateCount: number
          dataUpdatedAt: number
          error: TError | null
          errorUpdateCount: number
          errorUpdatedAt: number
          fetchFailureCount: number
          fetchFailureReason: TError | null
          fetchMeta: FetchMeta | null
          isInvalidated: boolean
          status: QueryStatus
          fetchStatus: FetchStatus
        }
        ```
        -   queryKey
        -   queryHash
        -   query.meta (query meta data)

```tsx
// packages/query-core/src/hydration.ts

export function dehydrate(client: QueryClient, options: DehydrateOptions = {}): DehydratedState {
	const filterMutation = options.shouldDehydrateMutation ?? client.getDefaultOptions().dehydrate?.shouldDehydrateMutation ?? defaultShouldDehydrateMutation;

	const mutations = client
		.getMutationCache()
		.getAll()
		.flatMap(mutation => (filterMutation(mutation) ? [dehydrateMutation(mutation)] : []));

	const filterQuery = options.shouldDehydrateQuery ?? client.getDefaultOptions().dehydrate?.shouldDehydrateQuery ?? defaultShouldDehydrateQuery;

	const serializeData = options.serializeData ?? client.getDefaultOptions().dehydrate?.serializeData ?? defaultTransformerFn;

	// ì—¬ê¸°ì„œ ì¿¼ë¦¬í´ë¼ì´ì–¸íŠ¸ì˜ ì¿¼ë¦¬ìºì‹œë¥¼ ëª¨ë‘ ê°€ì ¸ì™€ ì¿¼ë¦¬ë¥´ ìˆœíšŒí•˜ë©° ì§ë ¬í™” ê°€ëŠ¥í•œ ë°ì´í„°ë¥¼ ì¶”ì¶œí•©ë‹ˆë‹¤.
	const queries = client
		.getQueryCache()
		.getAll()
		.flatMap(query => (filterQuery(query) ? [dehydrateQuery(query, serializeData)] : []));

	return { mutations, queries }; // HydrationBoundaryì˜ stateì— ì „ë‹¬ë  ê°ì²´ !
}
```

### 3. dehyrateëœ queryëŠ” ë‹¤ì‹œ hydrate í•´ì¤˜ì•¼ê² ì£ ? : HydrationBoundaryì˜ ì—­í• 

-   ( v4ë²„ì „ì—ì„œëŠ” <Hydrate/> ë¼ëŠ” ì»´í¬ë„ŒíŠ¸ë¡œ ëª…ëª…ë˜ì–´ìˆìŠµë‹ˆë‹¤. )
-   **<HydrationBoundary state={dehydratedState}/>**
    -   client component ( â€use clientâ€ declared )
    -   ì¿¼ë¦¬ í´ë¼ì´ì–¸íŠ¸ì— dehydratedëœ ì¿¼ë¦¬ë¥¼ ë‹¤ì‹œ ë³µì›(hydrate)í•©ë‹ˆë‹¤.
        (ë‹¨, queryClientë¥¼ ì£¼ì…í•˜ëŠ” QueryProviderë³´ë‹¤ ì•ˆìª½ì— ìˆì–´ì•¼í•©ë‹ˆë‹¤.)

```tsx
// packages/react-query/src/HydrationBoundary.tsx

export const HydrationBoundary = ({
	children,
	options = {},
	state, // dehydrate(queryClient)
	queryClient,
}: HydrationBoundaryProps) => {
	const client = useQueryClient(queryClient);
	const [hydrationQueue, setHydrationQueue] = React.useState<DehydratedState["queries"] | undefined>();

	const optionsRef = React.useRef(options);
	optionsRef.current = options;

	React.useMemo(() => {
		if (state) {
			if (typeof state !== "object") {
				return;
			}

			const queryCache = client.getQueryCache();
			const queries = (state as DehydratedState).queries || [];

			// ìºì‹œì— ì—†ëŠ” ìƒˆë¡œìš´ ì¿¼ë¦¬ë“¤
			const newQueries: DehydratedState["queries"] = [];
			// ì´ë¯¸ ìºì‹œì— ìˆëŠ” ì¿¼ë¦¬ë“¤
			const existingQueries: DehydratedState["queries"] = [];

			for (const dehydratedQuery of queries) {
				const existingQuery = queryCache.get(dehydratedQuery.queryHash);

				if (!existingQuery) {
					// ìƒˆë¡œìš´ ì¿¼ë¦¬ë¼ë©´ newQueries ë°°ì—´ì— push
					newQueries.push(dehydratedQuery);
				} else {
					const hydrationIsNewer = dehydratedQuery.state.dataUpdatedAt > existingQuery.state.dataUpdatedAt;
					const queryAlreadyQueued = hydrationQueue?.find(query => query.queryHash === dehydratedQuery.queryHash);

					if (
						// ì¿¼ë¦¬ê°€ ì´ë¯¸ ì¡´ì¬í•  ë•Œ ë” ìµœì‹  ë°ì´í„°ì¸ ê²½ìš°ë§Œ existingQueriesì— ì¶”ê°€
						hydrationIsNewer &&
						(!queryAlreadyQueued || dehydratedQuery.state.dataUpdatedAt > queryAlreadyQueued.state.dataUpdatedAt)
					) {
						existingQueries.push(dehydratedQuery);
					}
				}
			}

			if (newQueries.length > 0) {
				// It's actually fine to call this with queries/state that already exists
				// in the cache, or is older. hydrate() is idempotent for queries.
				// ì¿¼ë¦¬ìºì‹œì˜ ì¿¼ë¦¬ëŠ” Mapìœ¼ë¡œ ê´€ë¦¬ë˜ì–´ ì´ë¯¸ ìºì‹œì— ì¡´ì¬í•˜ëŠ” ì¿¼ë¦¬ë¼ë©´ hydrateê°€ ì—¬ëŸ¬ë²ˆ í˜¸ì¶œë˜ì–´ë„
				// ë©±ë“±ì„±(ë‹¤ì‹œ ì—°ì‚°í•˜ì—¬ë„ ê²°ê³¼ê°€ ê°™ìŒ)ì„ ìœ ì§€í•©ë‹ˆë‹¤.
				hydrate(client, { queries: newQueries }, optionsRef.current);
			}
			if (existingQueries.length > 0) {
				setHydrationQueue(prev => (prev ? [...prev, ...existingQueries] : existingQueries));
			}
		}
	}, [client, hydrationQueue, state]);

	React.useEffect(() => {
		// ê¸°ì¡´ì— ìºì‹œëœ ì¿¼ë¦¬ì˜ hydrateëŠ” ë Œë”ë§ í›„ side effectë¡œ ì²˜ë¦¬
		// ì—¬ê¸°ì„œ hydrateëŠ” ìµœì‹  query state(dehydrateStateê¸°ë°˜)ë¡œ ì—…ë°ì´íŠ¸ë¥¼ ë§í•¨.
		if (hydrationQueue) {
			hydrate(client, { queries: hydrationQueue }, optionsRef.current);
			setHydrationQueue(undefined);
		}
	}, [client, hydrationQueue]);

	return children as React.ReactElement;
};
```

### newQueriesì™€ hydrationQueueë¡œ ë‚˜ëˆ„ì–´ hydrateí•´ì•¼í•˜ëŠ” ì´ìœ ?

> newQueries( ì¿¼ë¦¬ ìºì‹œì— ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ì¿¼ë¦¬ ) ëŠ” ì¦‰ê°ì ìœ¼ë¡œ hydrate(ì¿¼ë¦¬ìºì‹œì— ì¿¼ë¦¬ ì¶”ê°€)ê°€ ì´ë¤„ì ¸ì•¼í•¨. ë°˜ë©´, ì´ë¯¸ ì¿¼ë¦¬ ìºì‹œì— ì¡´ì¬í•˜ëŠ” hydrationQueue ì¿¼ë¦¬ë¥¼ side-effectë¡œ ì²˜ë¦¬í•˜ëŠ” ê²ƒì€ ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ì¿¼ë¦¬ëŠ” ì‹œê¸‰í•œ ì—…ë°ì´íŠ¸ê°€ ì•„ë‹ ë¿ë§Œ ë”ëŸ¬ , ë Œë”ë§ ë„ì¤‘ ì¿¼ë¦¬ ì—…ë°ì´íŠ¸ë¡œì¸í•œ ë¶ˆí•„ìš”í•œ ì—…ë°ì´íŠ¸ë¥¼ ë°œìƒì‹œí‚¬ ìˆ˜ ìˆê¸° ë•Œë¬¸ìœ¼ë¡œ ì¶”ì¸¡ ë¨.ğŸ§

---

### + ) App router ì“°ë©´ server componentë¡œ í•´ê²°ë˜ëŠ”ê±° ì•„ë‹ê¹Œìš”?

ì €ë„ ê·¸ë ‡ê²Œ ìƒê°í•©ë‹ˆë‹¤. êµ³ì´ ì²˜ìŒë¶€í„° ê¸°ëŠ¥ì„ ê°œë°œí• ë•Œ ìœ„ì™€ê°™ì€ íŒ¨í„´ì„ ë„ì…í•  í•„ìš”ëŠ” ì—†ë‹¤ê³  ìƒê°í•©ë‹ˆë‹¤.

ê°œë³„ì ì¸ ì»´í¬ë„ŒíŠ¸ì—ì„œ await fetchQueryë¥¼ ìˆ˜í–‰í•  ë•Œ ë°œìƒí•˜ëŠ” ì›Œí„°í´ ë¬¸ì œ(suspenseë¡œ ì™„í™”í•  ìˆ˜ ìˆì§€ë§Œ), next fetchì—ì„œ ì œê³µí•˜ëŠ” API ìºì‹±ì„ í™œìš©í•  ìˆ˜ ì—†ëŠ” ë¬¸ì œë“±ì„ ìƒê°í•´ë³´ë©´ êµ³ì´ ì‚¬ìš©í•  í•„ìš”ëŠ” ì—†ì„ ê²ƒì…ë‹ˆë‹¤.

í•˜ì§€ë§Œ íŠ¹ì • ìƒí™©ì—ì„œëŠ” ì‚¬ìš©í•´ ë³¼ë§Œí•œ ê°€ì¹˜ê°€ ìˆë‹¤ê³  ìƒê°í•©ë‹ˆë‹¤.

> pageë¼ìš°í„° â‡’ appë¼ìš°í„°ë¡œ í˜ì´ì§€ë¥¼ ë§ˆì´ê·¸ë ˆì´ì…˜ í•˜ëŠ” CASE
> : pageë¼ìš°í„°ì— ì´ë¯¸ waterfall ë°©ì‹ìœ¼ë¡œ ìš”ì²­í•˜ê³  ìˆëŠ” ë³µìˆ˜ì˜ queryë“¤ì´ ì¡´ì¬í•˜ëŠ” ìƒí™©ì—ì„œ
> app router ë§ˆì´ê·¸ë ˆì´ì…˜ê³¼, FCPë¥¼ ê°œì„ ì„ ë‘ ê°€ì§€ ëª©í‘œë¥¼ ìµœì†Œí•œì˜ ë³€ê²½ì ìœ¼ë¡œ ë‹¬ì„±í•˜ê³  ì‹¶ë‹¤ë©´?

ë‹¤ìŒê³¼ ê°™ì€ í”„ë¡œì„¸ìŠ¤ë¡œ ê°€ëŠ¥í•  ê²ƒì´ë¼ ìƒê°í•©ë‹ˆë‹¤.

**step1) pageë¥¼ í†µì±„ë¡œ app routerì— ì˜®ê¸°ê³ , ê·¸ í˜ì´ì§€ë¥¼ ê°ì‹¸ëŠ” layout ì»´í¬ë„ŒíŠ¸ë¥¼ ì •ì˜í•©ë‹ˆë‹¤.**

**step2) layoutì»´í¬ë„ŒíŠ¸ì—ì„œ ê°œë³„ ì»´í¬ë„ŒíŠ¸ì—ì„œ ì‚¬ìš©í•˜ë˜ ì—¬ëŸ¬ ì¿¼ë¦¬ë“¤ì„ prefetchí•©ë‹ˆë‹¤. ( promise.allSetteled )**

**step3) layoutì—ì„œ HydrationBoundaryë¥¼ importí•´, í•´ë‹¹ í˜ì´ì§€ì—ì„œ prefetchëœ dehydrate stateë¥¼ ì£¼ì…í•©ë‹ˆë‹¤.**

```tsx
// RootLayoutì´ ì•„ë‹™ë‹ˆë‹¤. ê°œë³„ í˜ì´ì§€ Layoutì…ë‹ˆë‹¤.
export default async function PageLayout({ children }: { children: React.ReactNode }) {
	await Promise.allSettled([
		queryClient.prefetchQuery({
			queryKey: ["posts"],
			queryFn: getPosts,
		}),
		queryClient.prefetchQuery({
			queryKey: ["users"],
			queryFn: getUsers,
		}),
		queryClient.prefetchQuery({
			queryKey: ["comments"],
			queryFn: getComments,
		}),
	]);

	return (
		<html>
			<head>...</head>
			<body>
				<HydrationBoundary state={dehydrate(queryClient)}>{children} // pageë¼ìš°í„°ì˜ í˜ì´ì§€ ì»´í¬ë„ŒíŠ¸ê°€ ë“¤ì–´ê°€ë©´ ë˜ê² ì£ ?</HydrationBoundary>
			</body>
		</html>
	);
}
```

ì´ì œ ìš°ë¦¬ëŠ” prefetchí•œ ì¿¼ë¦¬ë¥¼ ì¿¼ë¦¬ í´ë¼ì´ì–¸íŠ¸ì˜ ìºì‹œì— ë³´ìœ í•˜ë¯€ë¡œ,

useQuery ì¸í„°í˜ì´ìŠ¤ë¥¼ ê·¸ëŒ€ë¡œ ìœ ì§€í•˜ë©°, ìµœì†Œí•œì˜ ë³€ê²½ì ìœ¼ë¡œ FCPë¥¼ í•¨ê»˜ ê°œì„ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

-   ë˜í•œ ë³„ë„ì˜ ì „ì—­ìƒíƒœ ì„¤ì • ì—†ì´, ì„œë²„ ìƒíƒœë¥¼ ì¿¼ë¦¬ í´ë¼ì´ì–¸íŠ¸ ê¸°ë°˜ìœ¼ë¡œ ì†Œë¹„í•  ìˆ˜ ìˆëŠ” ì¥ì ì´ ìˆìŠµë‹ˆë‹¤.
